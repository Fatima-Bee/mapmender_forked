<!-- To do: 
- Add multiple select for Hazards Survey
- Make the closure symbol a circle with slash
- Make the hazard symbol a caution w/ exclamation
- Improved reopening logic.  Concern that once marked as closed, users may route away indefinitely.  Need an automated way detect reopening.
-->

<!DOCTYPE html>
<html lang="en">
  <head>

    <!-- meta for the browser to allow for mobiel first design -->
    <meta charset="utf-8"/> <!--This ensures that the web page can display characters from various languages and character sets.-->
    
    <!--Sets the viewport properties for the web page. The viewport determines how the web page is displayed on different devices and screen sizes. 
    The "initial-scale=1" property sets the initial zoom level of the page to 100%, while the "maximum-scale=1" and "user-scalable=no" properties 
    prevent users from zooming in or out of the page using pinch or zoom gestures on their devices.-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Mapmender - See the World as it Is — Not as it Was.</title>

    <!-- To make the map fill the browser window -->
    <style>
        html,
        body,
        #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
        }

        /* Adding CSS for Survey button. */
        .addRecordBtn {
        position: absolute;
        z-index: 10;
        top: 60px;   /* push it down below the search widget */
        right: 10px;
        background-color: #feffff;
        color: rgb(132, 132, 132);
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        font-size: 14px;
        cursor: pointer;
        text-decoration: none;
        box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        .addRecordBtn:hover {
        background-color: #005a87;
        }

        #uploadContainer {
        position: absolute;
        bottom: 20px;   /* position from bottom */
        left: 20px;     /* position from left */
        z-index: 99;
        background: white;
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

    </style>


    <!-- References the main.css style sheet, which contains styles specific to Esri widgets and components. -->
    <!-- 'rel' means "relationship" between the current HTML document and the linked resource -->
    <!-- 'href' means hyperlink reference -->
    <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css"/>

    <!-- Loading the ArcGIS Maps SDK for JavaScript from a CDN. When new versions of the API are released, update the version number to match the newly released version. -->
    <script src="https://js.arcgis.com/4.29/"></script>
    
  </head>

  <body>
   <!-- hello world text to check if everything worked -->
   <!-- <h1>Hello World! I am ready to collect data.</h1> -->

   
    <!-- Adding the Survey button. -->
    <a href="https://survey123.arcgis.com/share/679dbea6861f447ca59cdfcb53ae88b5" target="_blank" class="addRecordBtn">Add Record</a>

    <!-- DOM element to hold the upload feature. -->
    <div id="uploadContainer">
        <h4>Check a Route for Closures(.GPX)</h4>
        <input type="file" id="gpxInput" accept=".gpx" />
        <br><br>
        <label>Buffer (meters): <input type="number" id="bufferInput" value="50" /></label>
    </div>

    <!-- DOM element to hold the main map.  -->
    <!-- <div> (short for division) is a generic HTML block element. It doesn’t show anything by itself — it’s just a rectangle you can style. -->
    <div id="viewDiv"></div>

    <script> 
        window.onload = () => {  // delay running the script until the DOM is ready, else I see: '#container element with id 'viewDiv' not found'
            // esri/Map - loads code specific to creating a map
            // esri/views/MapView - loads code that allows for viewing the map in 2D
            // 'require' loads JS modules asynchronously.  
            // The function (Map, MapView) => { ... } runs after the modules are loaded, with each module passed in as an argument.
            require([
                "esri/config", 
                "esri/Map", 
                "esri/views/MapView", 
                "esri/widgets/Locate", 
                "esri/widgets/Search", 
                "esri/layers/FeatureLayer",
                "esri/geometry/geometryEngine",
                "esri/Graphic"
            ], (esriConfig, Map, MapView, Locate, Search, FeatureLayer, geometryEngine, Graphic) => { 
                
                // Log into the API with a private key
                esriConfig.apiKey = "AAPTxy8BH1VEsoebNVZXo8HurC-WNby9xVB5CaUbYmSkdtsZmMyGnfH1JuHkPFwFFSBd3Z-v-N7m_s6f1dmRgKVLamcFHqSo0cttTR09tKsFzmbXZUhJIfKzl2R6HLQtKWGyGlzHobrqUHrwEOtLR9miyCr3AH4LGIs4bD8J_IfjNZJFYZiID06JxdIjFa_CX5wLcu2d2_5Pr2huNg7-z1mKuSnOsU5nBktIt9t_XxG-4s-ytgy_1uafScxdrTypBn4BAT1_UUjVT5i4";

                // This module creates a map object that defines the basemap and operational layers.
                const map = new Map({
                    basemap: "arcgis-navigation"
                    // basemap: "satellite"
                    // Try any of these: "arcgis-imagery", "arcgis-imagery-standard", "arcgis-imagery-labels", "arcgis-light-gray", "arcgis-dark-gray", "arcgis-navigation", "arcgis-navigation-night", "arcgis-streets", "arcgis-streets-night", "arcgis-streets-relief", "arcgis-topographic", "arcgis-oceans", "osm-standard", "osm-standard-relief", "osm-streets", "osm-streets-relief", "osm-light-gray", "osm-dark-gray", "arcgis-terrain", "arcgis-community", "arcgis-charted-territory", "arcgis-colored-pencil", "arcgis-nova", "arcgis-modern-antique", "arcgis-midcentury", "arcgis-newspaper", "arcgis-hillshade-light", "arcgis-hillshade-dark", "arcgis-human-geography", "arcgis-human-geography-dark"
                })

                // Creates a MapView instance → the 2D view that renders your Map object in the browser.
                // Without this, i'd have a map defined in memory, but nothing would be drawn to the screen.
                // “Take my Map object and render it inside the HTML element called viewDiv as a 2D map.”
                const view = new MapView({
                    container: "viewDiv",               // The HTML element id where the map will appear.  Tells the view where (which DOM node) in the HTML to put the map.  Looks for a <div> with id="viewDiv"
                    map: map,                           // The map object (from earlier) to display inside the viewDiv.
                    center: [-89.4012, 43.0731],        // Madison, WI (fallback)
                    zoom: 13                            // Zoom level of the map.  0 > whole world, 23 street level.
                })

                // Try to center the map on the user's location
                if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(               // Built-in browser API for location.
                    (position) => {
                        // Success — center the view on user's location
                        const userLongitude = position.coords.longitude;
                        const userLatitude = position.coords.latitude;

                        view.center = [userLongitude, userLatitude];        // Recenter the map on the user's longitude and latitude, if possible.
                        view.zoom = 13;

                        console.log(`Centered on user location: ${userLongitude}, ${userLatitude}`);
                    },
                    (error) => {
                        console.warn("Geolocation failed or denied. Using fallback (Madison, WI).", error);
                    },
                    { enableHighAccuracy: true, timeout: 10000 }        // Uses GPS (if available) instead of IP-based location.
                );

                } else {
                    console.warn("Geolocation not supported. Using fallback (Madison, WI).");
                }

                // Adding a Locate button (widget)
                const locateBtn = new Locate({
                    // view (on the left) >  This is the property name of the Locate widget’s options.
                    // view (on the right) >  This is the variable created earlier in the code.
                    view: view                          // Tell the Locate widget which MapView it should control.
                })

                view.ui.add(locateBtn, {                // Add the locate widget to the view's built-in UI
                    position: "top-left"                // Position the widget in the top-left corner of the map
                });

                // Adding an Address or Search bar, using Search Widget.
                const searchWidget = new Search({
                    // view: (on the left) >  This is the property name of the Locate widget’s options.
                    // view (on the right) >  This is the variable created earlier in the code.
                    view: view                          // Tell the Search widget which MapView it shoudl control. 
                });

                view.ui.add(searchWidget, {
                    position: "top-right"
                });

                // Creating the Survey FeatureLayer from the feature service.
                const layer = new FeatureLayer({
                    // url: "https://services.arcgis.com/HRPe58bUyBqyyiCt/arcgis/rest/services/Closure_Layer/FeatureServer/0"
                    url: "https://services.arcgis.com/HRPe58bUyBqyyiCt/arcgis/rest/services/Closure_Layer_Public/FeatureServer/0",
                    outFields: ["*"], // make all fields available to the popup
                    popupTemplate: {
                        title: "Road Closure",
                        content: `
                        <b>Status:</b> {access_status}<br>
                        <b>Impassability:</b> {impasse_reasons}<br>
                        <b>Hazards:</b> {hazards}<br>
                        <b>Latitude:</b> {esrignss_latitude}<br>
                        <b>Longitude:</b> {esrignss_longitude}<br>
                        <b>Reported by:</b> {Creator}<br>
                        <b>Last Updated:</b> {EditDate}<br>
                        <b>Notes:</b> {notes}
                        `
                    }
                });

                // Adding the Survey FeatureLayer to the map.
                map.add(layer);

                // GPX handling section
                document.getElementById("gpxInput").addEventListener("change", handleGPXUpload);

                function handleGPXUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const bufferDistance = Number(document.getElementById("bufferInput").value) || 50;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const parser = new DOMParser();
                    const xml = parser.parseFromString(e.target.result, "application/xml");
                    const trkpts = xml.getElementsByTagName("trkpt");

                    if (!trkpts.length) {
                    alert("No GPS track points found in the GPX file.");
                    return;
                    }

                    const path = [];
                    for (let i = 0; i < trkpts.length; i++) {
                    const lat = parseFloat(trkpts[i].getAttribute("lat"));
                    const lon = parseFloat(trkpts[i].getAttribute("lon"));
                    path.push([lon, lat]);
                    }

                    const polyline = {
                    type: "polyline",
                    paths: [path],
                    spatialReference: { wkid: 4326 }
                    };

                    // ✅ Project polyline to Web Mercator before buffering
                    require([
                    "esri/geometry/projection",
                    "esri/geometry/support/webMercatorUtils"
                    ], (projection, webMercatorUtils) => {

                    projection.load().then(() => {

                        // Get SRs
                        const gpxSR = { wkid: 4326 };                  // GPX native
                        const layerSR = layer.spatialReference;        // e.g. 4326 or 3857

                        // Project GPX polyline into the layer's SR (ensures perfect alignment)
                        let polylineProjected = projection.project(polyline, layerSR);

                        console.log("Original GPX polyline:", polyline);
                        // console.log("Projected polyline:", polylineProjected);
                        console.log("Projected polyline SR:", polylineProjected.spatialReference);
                        // console.log("FeatureLayer spatial reference:", layer.spatialReference);
                        console.log("FeatureLayer WKID:", layer.spatialReference.wkid);

                        // Center map on uploaded route
                        view.goTo({ target: polylineProjected, zoom: 10 }).catch(err => console.warn(err));

                        // Add GPX track to the map for visualization
                        const gpxLineGraphic = new Graphic({
                        geometry: polylineProjected,
                        symbol: {
                            type: "simple-line",
                            // color: [0, 120, 255, 0.8], // bright blue line
                            // color: [128, 0, 128, 0.8],
                            color: [255, 0, 255, 0.8],
                            width: 2
                        }
                        });

                        // Optional: clear old GPX tracks before adding new
                        view.graphics.removeAll();
                        view.graphics.add(gpxLineGraphic);

                        // If projection service unavailable, fall back to WebMercatorUtils
                        if (!polylineProjected) {
                        polylineProjected = webMercatorUtils.geographicToWebMercator(polyline);
                        console.log("Fallback projected polyline (Web Mercator):", polylineProjected);
                        }

                        // Buffer in meters only if layerSR is linear
                        let bufferGeom;
                        if (layerSR.isGeographic) {
                        // project to a linear SR for buffering
                        const tempLinear = { wkid: 3857 };
                        const tempProj = projection.project(polyline, tempLinear);
                        const buffered = geometryEngine.buffer(tempProj, bufferDistance, "meters");
                        // reproject back to layer's SR
                        bufferGeom = projection.project(buffered, layerSR);
                        } else {
                        bufferGeom = geometryEngine.buffer(polylineProjected, bufferDistance, "meters");
                        }

                        // <<< ADD THIS BLOCK TO SHOW THE BUFFER ON THE MAP >>>
                        require(["esri/Graphic"], (Graphic) => {
                        const bufferGraphic = new Graphic({
                            geometry: bufferGeom,
                            symbol: {
                            type: "simple-fill",
                            color: [200, 160, 255, 0.1], // light blue, semi-transparent
                            outline: {
                                // color: [0, 0, 255, 0.8],
                                color: [128, 0, 128, 0.2], // bright blue line
                                width: 0.5
                            }
                            }
                        });
                        view.graphics.add(bufferGraphic);
                        });

                        // Convert buffer back to WGS84 for querying (layer likely in 4326)
                        const bufferWGS84 = projection.project(bufferGeom, { wkid: 4326 });

                        const query = layer.createQuery();
                        query.geometry = bufferWGS84;
                        query.spatialRelationship = "intersects";
                        query.returnGeometry = true;
                        query.outFields = ["access_status", "impasse_reasons"];

                        layer.queryFeatures(query).then((results) => {
                        if (results.features.length > 0) {
                            alert(`⚠️ WARNING: ${results.features.length} closures found within ${bufferDistance}m of your route.`);
                            results.features.forEach(f => {
                            f.symbol = {
                                type: "simple-marker",
                                color: "red",
                                size: "10px"
                            };
                            });
                            view.graphics.addMany(results.features);
                        } else {
                            alert("✅ No closures found near your uploaded route.");
                        }
                        }).catch(err => console.error("Query failed", err));
                    });
                    });
                };
                reader.readAsText(file);
                }

            });
        };
    </script>
  </body>
</html>
