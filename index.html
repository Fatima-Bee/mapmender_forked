<!-- To do: 
- Add multiple select for Hazards Survey
- Make the closure symbol a circle with slash
- Make the hazard symbol a caution w/ exclamation
- Improved reopening logic.  Concern that once marked as closed, users may route away indefinitely.  Need an automated way detect reopening.
- Add a Map Gallery
- Rerouting
- Road Closure API 
-->

<!DOCTYPE html>
<html lang="en">
  <head>

    <!-- meta for the browser to allow for mobiel first design -->
    <meta charset="utf-8"/> <!--This ensures that the web page can display characters from various languages and character sets.-->
    
    <!-- Sets the viewport properties for the web page. The viewport determines how the web page is displayed on different devices and screen sizes. 
    The "initial-scale=1" property sets the initial zoom level of the page to 100%. -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Title of the webpage, displayed in the browser tab. -->
    <title>Mapmender - See the World as it Is — Not as it Was.</title> 

    <style>
        /* These rules apply to the <html> element, the <body> element, and the #viewDiv (which is the container for the map). */
        html,
        body,
        #viewDiv {
            padding: 0;                      /* Removes all default inner spacing around content. */
            margin: 0;                       /* Removes default outer spacing applied by browsers. */
            height: 100%;                    /* Ensures each element takes the full available viewport height. */
            width: 100%;                     /* Ensures each element takes the full available viewport width. */
            font-family: Arial, sans-serif;  /* Sets a consistent font for text elements (fallback to any sans-serif). */
        }

        /* === Left panel styling === */
        #leftPanel {
            position: absolute;          /* Positions the panel relative to the map container (not affected by normal layout flow). */
            top: 0;                      /* Aligns the top edge of the panel with the top of the window. */
            left: 0;                     /* Anchors the panel to the left side of the screen. */
            height: 100%;                /* Makes the panel stretch the full height of the viewport. */
            width: 250px;                /* Sets the panel’s width when expanded (default state). */
            background: #892be2a3;     /* Applies a background color and transparency. */
            color: white;              /* Sets all text inside the panel to white for contrast. */
            box-shadow: 2px 0 5px rgba(0,0,0,0.3); /* Adds a subtle shadow along the right edge for depth. */
            z-index: 100;                /* Ensures the panel sits above the map and other elements. */
            overflow: hidden;            /* Hides any overflowing content (useful when collapsing). */
            transition: width 0.3s;      /* Smoothly animates width changes (e.g., when collapsing/expanding). */
        }

        #leftPanel.collapsed {
            width: 40px;             /* collapsed width, just shows toggle button */
        }

        /* === Collapse/Expand Toggle button styling === */
        #togglePanelBtn {
            display: block;          /* Makes the button take up the full available width (behaves like a block element). */
            margin: 10px;            /* Adds space around the button for padding from the panel edges. */
            font-size: 20px;         /* Increases the icon or text size for visibility. */
            cursor: pointer;         /* Changes the cursor to a pointer (hand icon) when hovered, indicating it's clickable. */
            background: none;        /* Removes any default button background styling. */
            border: none;            /* Removes the default button border for a clean, flat look. */
            color: white;            /* Sets the icon or text color to white to match the panel theme. */
        }

        /* === Panel content styling ensures that everything inside the left panel (buttons, inputs, text, etc.) is neatly spaced and scrollable when necessary === */
        #panelContent {
            padding: 10px;                        /* Adds inner spacing so text and buttons aren’t flush against the edges. */
            max-height: calc(100% - 50px);        /* Ensures the content fits within the panel, leaving space for the toggle button above the panel content. */
            overflow-y: auto;                     /* Adds a vertical scrollbar *only* if content exceeds available height. */
        }

        /* Hide content when collapsed */
        #leftPanel.collapsed #panelContent {
            display: none;
        }

        /* For any Header in the panel */
        #panelContent h4 {
            margin: 0 0 10px 0;          /* Top: 0, Right: 0, Bottom: 10px, Left: 0 spacing below the header */
            font-size: 14px;             /* Sets a smaller, more subtle font size for panel headers */
            font-weight: normal;         /* Makes the text lighter instead of bold */
            display: flex;               /* Allows horizontal alignment of content, useful if header has icons + text */
            align-items: center;         /* Vertically centers any inline content (e.g., icons) within the header */
        }

        /* Input fields inside the expandable toolbar (e.g., GPX upload and buffer size) */
        #panelContent input[type="file"],
        #panelContent input[type="number"] {
            margin-top: 6px;          /* Adds spacing above each input field for visual separation */
            width: 100%;              /* Makes input fields span the full width of the panel */
            padding: 6px 8px;         /* Adds inner spacing so text isn’t flush against edges */
            border-radius: 4px;       /* Softly rounds the corners for a cleaner look */
            border: none;             /* Removes the browser’s default border */
            outline: none;            /* Prevents the blue highlight when the field is focused */
            font-family: inherit;     /* Ensures the same font as the surrounding text */
            font-size: inherit;       /* Keeps consistent text sizing with the panel */
            color: black;             /* Ensures the entered text (e.g., buffer value) is visible */
            background-color: white;  /* Matches the button style for a unified look */
            box-sizing: border-box;   /* Includes padding in the total width to prevent overflow */
        }

        /* Label for buffer input */
        #panelContent label {
            display: block;          /* Makes each label take up the full width (so it sits above its input) */
            margin-top: 8px;         /* Adds spacing above each label for separation from previous elements */
            font-size: 14px;         /* Sets a readable, consistent text size for all labels */
        }

        /* “Report a Closure” button inside the left panel */
        #addRecordBtn {
            display: block;             /* Ensures the button is treated as a block element (fills the container width) */
            width: 100%;                /* Makes the button stretch across the entire panel width */
            text-align: center;         /* Centers the button text horizontally */
            background-color: white;  /* Gives the button a white fill to stand out from the purple panel */
            color: #892be2;           /* Uses the project’s purple color for text to match overall theme */
            padding: 10px 0;            /* Adds vertical spacing inside the button for comfortable click area */
            border: none;               /* Removes default browser button borders */
            border-radius: 6px;         /* Softly rounds the button corners for a clean, modern look */
            font-size: 14px;            /* Sets consistent text size */
            font-weight: normal;        /* Makes the button label stand out */
            cursor: pointer;            /* Changes cursor to pointer to indicate it's clickable */
            text-decoration: none;      /* Prevents underline in case the button is rendered as a link */
            box-shadow: 0 0 5px rgba(0,0,0,0.3); /* Adds subtle shadow for depth and contrast */
            margin-bottom: 12px;        /* Adds spacing below to separate it from the next section */
        }

        /* Hover effect for button */
        #addRecordBtn:hover {
            background-color: #f4ecec;  /* subtle light gray hover */
        }

        /* Horizontal separator between button and GPX section */
        #panelContent hr {
            border: 0;
            border-top: 1px solid rgba(255,255,255,0.3);
            margin: 10px 0;
        }

        /* Ensure consistent font for all panel content */
        #panelContent,
        #panelContent h4,
        #panelContent label,
        #panelContent input,
        #panelContent button {
            font-family: Calibri, Candara, Segoe, sans-serif;
            font-size: 17px; 
        }

        /* Scroll bar styling for the #panelContent element */
        /* Target the entire scrollbar inside #panelContent (WebKit browsers only) */
        #panelContent::-webkit-scrollbar {
            width: 6px; /* Sets the width of the vertical scrollbar to 6px */
        }

        /* Target the draggable “thumb” part of the scrollbar */
        #panelContent::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3); /* Semi-transparent white color for the thumb */
            border-radius: 3px; /* Rounds the corners of the scrollbar thumb */
        }

        /* Target the track (the background area behind the thumb) */
        #panelContent::-webkit-scrollbar-track {
            background: transparent; /* Makes the track fully transparent */
        }
    </style>

    <!-- References the main.css style sheet, which contains styles specific to Esri widgets and components. -->
    <!-- 'rel' means "relationship" between the current HTML document and the linked resource -->
    <!-- 'href' means hyperlink reference -->
    <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css"/>

    <!-- Loading the ArcGIS Maps SDK for JavaScript from a CDN. -->
    <script src="https://js.arcgis.com/4.29/"></script>
    
  </head>

  <body>

    <!-- DOM element to hold the collapsible left toolbar.  -->
    <!-- <div> (short for division) is a generic HTML block element. It doesn’t show anything by itself — it’s just a rectangle you can style. -->
    <div id="leftPanel" class="collapsed"> <!-- Left sidebar panel, starts collapsed -->
        <button id="togglePanelBtn">☰</button> <!-- Button to expand/collapse the panel (hamburger icon) -->
        <div id="panelContent"> <!-- Container for the panel’s content -->
            <button id="addRecordBtn">Report a Closure</button> <!-- Button to trigger reporting a closure -->
            <hr style="border: 1px solid rgba(255,255,255,0.3); margin: 15px 0;" /> <!-- Divider line between sections -->
            <h4>Check a Route for Closures (.GPX)</h4> <!-- Section title for GPX route checking -->
            <input type="file" id="gpxInput" accept=".gpx" /> <!-- File input to upload GPX file -->
            <br><br> <!-- Spacing between inputs -->
            <label>Buffer (meters): <input type="number" id="bufferInput" value="50" /> <!-- Number input for buffer distance in meters --></label>
        </div> <!-- End of panelContent -->
    </div> <!-- End of leftPanel -->

    <!-- DOM element to hold the main map.  -->
    <div id="viewDiv"></div>

    <script> 
        window.onload = () => {  // delay running the script until the DOM is ready, else I see: '#container element with id 'viewDiv' not found'
            // esri/Map - loads code specific to creating a map
            // esri/views/MapView - loads code that allows for viewing the map in 2D
            // 'require' loads JS modules asynchronously.  
            // The function (Map, MapView) => { ... } runs after the modules are loaded, with each module passed in as an argument.
            require([
                "esri/config", 
                "esri/Map", 
                "esri/views/MapView", 
                "esri/widgets/Locate", 
                "esri/widgets/Search", 
                "esri/layers/FeatureLayer",
                "esri/geometry/geometryEngine",
                "esri/Graphic"
            ], (esriConfig, Map, MapView, Locate, Search, FeatureLayer, geometryEngine, Graphic) => { 
                
                // Log into the API with a private key
                esriConfig.apiKey = "AAPTxy8BH1VEsoebNVZXo8HurC-WNby9xVB5CaUbYmSkdtsZmMyGnfH1JuHkPFwFFSBd3Z-v-N7m_s6f1dmRgKVLamcFHqSo0cttTR09tKsFzmbXZUhJIfKzl2R6HLQtKWGyGlzHobrqUHrwEOtLR9miyCr3AH4LGIs4bD8J_IfjNZJFYZiID06JxdIjFa_CX5wLcu2d2_5Pr2huNg7-z1mKuSnOsU5nBktIt9t_XxG-4s-ytgy_1uafScxdrTypBn4BAT1_UUjVT5i4";

                // This module creates a map object that defines the basemap and operational layers.
                const map = new Map({
                    basemap: "arcgis-navigation"
                    // Try any of these: "arcgis-imagery", "arcgis-imagery-standard", "arcgis-imagery-labels", "arcgis-light-gray", "arcgis-dark-gray", "arcgis-navigation", "arcgis-navigation-night", "arcgis-streets", "arcgis-streets-night", "arcgis-streets-relief", "arcgis-topographic", "arcgis-oceans", "osm-standard", "osm-standard-relief", "osm-streets", "osm-streets-relief", "osm-light-gray", "osm-dark-gray", "arcgis-terrain", "arcgis-community", "arcgis-charted-territory", "arcgis-colored-pencil", "arcgis-nova", "arcgis-modern-antique", "arcgis-midcentury", "arcgis-newspaper", "arcgis-hillshade-light", "arcgis-hillshade-dark", "arcgis-human-geography", "arcgis-human-geography-dark"
                })

                // Creates a MapView instance → the 2D view that renders your Map object in the browser.
                // Without this, i'd have a map defined in memory, but nothing would be drawn to the screen.
                // “Take my Map object and render it inside the HTML element called viewDiv as a 2D map.”
                const view = new MapView({
                    container: "viewDiv",               // The HTML element id where the map will appear.  Tells the view where (which DOM node) in the HTML to put the map.  Looks for a <div> with id="viewDiv"
                    map: map,                           // The map object (from earlier) to display inside the viewDiv.
                    center: [-89.4012, 43.0731],        // Madison, WI (fallback)
                    zoom: 13                            // Initial zoom level of the map.  0 > whole world, 23 street level.
                })

                // Try to center the map on the user's location
                if (navigator.geolocation) { // Check if the browser supports geolocation
                    navigator.geolocation.getCurrentPosition( // Built-in browser API to get user's location
                        (position) => { // Success callback when location is obtained
                            // Extract longitude and latitude from the position object
                            const userLongitude = position.coords.longitude;
                            const userLatitude = position.coords.latitude;

                            view.center = [userLongitude, userLatitude]; // Recenter the map on the user's coordinates
                            view.zoom = 13; // Zoom level to focus on user's location

                            console.log(`Centered on user location: ${userLongitude}, ${userLatitude}`); // Log coordinates for debugging
                        },
                        (error) => { // Error callback if geolocation fails or is denied
                            console.warn("Geolocation failed or denied. Using fallback (Madison, WI).", error); // Warn and fall back to default location
                        },
                        { enableHighAccuracy: true, timeout: 10000 } // Use GPS instead of IP Address if possible and timeout after 10s
                    );

                    } else { // If the browser does NOT support the Geolocation API
                        console.warn("Geolocation not supported. Using fallback (Madison, WI)."); // Log a warning and indicate that a default location will be used
                    }

                // Adding a Locate button (widget)
                const locateBtn = new Locate({
                    // view (on the left) > the property name expected by the Locate widget
                    // view (on the right) > the variable referencing your MapView instance created earlier
                    view: view // Assigns this Locate widget to control the specific MapView
                });

                view.ui.add(locateBtn, {                // Add the Locate widget to the view's built-in UI
                    position: "bottom-right"            // Position the widget in the bottom-right corner of the map
                });

                // Adding an Address or Search bar, using Search Widget.
                const searchWidget = new Search({
                    // view: (on the left) >  This is the property name of the Locate widget’s options.
                    // view (on the right) >  This is the variable created earlier in the code.
                    view: view                          // Tell the Search widget which MapView it should control. 
                });

                view.ui.add(searchWidget, {             // Add the Search widget to the view's built-in UI
                    position: "top-right"               // Position the widget in the bottom-right corner of the map
                });

                // Move the Zoom widget to the bottom-right
                view.ui.move("zoom", "bottom-right");

                // Creating a new FeatureLayer from an existing ArcGIS Feature Service.
                // This layer will represent survey data about road closures, making it visible and interactive on the map.
                const layer = new FeatureLayer({
                    // URL of the Feature Service and specific layer (0 = first layer in the service)
                    url: "https://services.arcgis.com/HRPe58bUyBqyyiCt/arcgis/rest/services/Closure_Layer_Public/FeatureServer/0",
                    
                    // outFields specifies which fields are available for popups, queries, and rendering.
                    // Using ["*"] makes all fields in the service available.
                    outFields: ["*"],

                    // Define how popups will display when a user clicks a feature.
                    popupTemplate: {
                        title: "Road Closure", // Popup header
                        content: `
                            <b>Status:</b> {access_status}<br>
                            <b>Impassability:</b> {impasse_reasons}<br>
                            <b>Hazards:</b> {hazards}<br>
                            <b>Latitude:</b> {esrignss_latitude}<br>
                            <b>Longitude:</b> {esrignss_longitude}<br>
                            <b>Reported by:</b> {Creator}<br>
                            <b>Last Updated:</b> {EditDate}<br>
                            <b>Notes:</b> {notes}
                        `
                        // Note: The {} syntax automatically pulls the attribute values from the feature.
                    }
                });

                // Add the FeatureLayer to the map instance so it will render on the map.
                map.add(layer);

                // GPX handling section
                document.getElementById("gpxInput").addEventListener("change", handleGPXUpload);
                document.getElementById("addRecordBtn").addEventListener("click", handleAddRecord);

                const leftPanel = document.getElementById("leftPanel");
                const toggleBtn = document.getElementById("togglePanelBtn");
                const viewDiv = document.getElementById("viewDiv");

                toggleBtn.addEventListener("click", () => {
                leftPanel.classList.toggle("collapsed");

                // Notify the ArcGIS MapView to resize when panel changes
                if (window.view) { // assuming your MapView is stored in `view`
                    window.view.padding = {
                    left: leftPanel.classList.contains("collapsed") ? 40 : 250,
                    top: 0,
                    right: 0,
                    bottom: 0
                    };
                    window.view.resize();
                }
                });

                function handleAddRecord() {
                    // Opens your Survey123 form in a new tab
                    window.open("https://survey123.arcgis.com/share/679dbea6861f447ca59cdfcb53ae88b5", "_blank");
                }

                function handleGPXUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const bufferDistance = Number(document.getElementById("bufferInput").value) || 50;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const parser = new DOMParser();
                    const xml = parser.parseFromString(e.target.result, "application/xml");
                    const trkpts = xml.getElementsByTagName("trkpt");

                    if (!trkpts.length) {
                    alert("No GPS track points found in the GPX file.");
                    return;
                    }

                    const path = [];
                    for (let i = 0; i < trkpts.length; i++) {
                    const lat = parseFloat(trkpts[i].getAttribute("lat"));
                    const lon = parseFloat(trkpts[i].getAttribute("lon"));
                    path.push([lon, lat]);
                    }

                    const polyline = {
                    type: "polyline",
                    paths: [path],
                    spatialReference: { wkid: 4326 }
                    };

                    // ✅ Project polyline to Web Mercator before buffering
                    require([
                    "esri/geometry/projection",
                    "esri/geometry/support/webMercatorUtils"
                    ], (projection, webMercatorUtils) => {

                    projection.load().then(() => {

                        // Get SRs
                        const gpxSR = { wkid: 4326 };                  // GPX native
                        const layerSR = layer.spatialReference;        // e.g. 4326 or 3857

                        // Project GPX polyline into the layer's SR (ensures perfect alignment)
                        let polylineProjected = projection.project(polyline, layerSR);

                        console.log("Original GPX polyline:", polyline);
                        // console.log("Projected polyline:", polylineProjected);
                        console.log("Projected polyline SR:", polylineProjected.spatialReference);
                        // console.log("FeatureLayer spatial reference:", layer.spatialReference);
                        console.log("FeatureLayer WKID:", layer.spatialReference.wkid);

                        // Center map on uploaded route
                        view.goTo({ target: polylineProjected, zoom: 10 }).catch(err => console.warn(err));

                        // Add GPX track to the map for visualization
                        const gpxLineGraphic = new Graphic({
                        geometry: polylineProjected,
                        symbol: {
                            type: "simple-line",
                            // color: [0, 120, 255, 0.8], // bright blue line
                            // color: [128, 0, 128, 0.8],
                            color: [255, 0, 255, 0.8],
                            width: 2
                        }
                        });

                        // Optional: clear old GPX tracks before adding new
                        view.graphics.removeAll();
                        view.graphics.add(gpxLineGraphic);

                        // If projection service unavailable, fall back to WebMercatorUtils
                        if (!polylineProjected) {
                        polylineProjected = webMercatorUtils.geographicToWebMercator(polyline);
                        console.log("Fallback projected polyline (Web Mercator):", polylineProjected);
                        }

                        // Buffer in meters only if layerSR is linear
                        let bufferGeom;
                        if (layerSR.isGeographic) {
                        // project to a linear SR for buffering
                        const tempLinear = { wkid: 3857 };
                        const tempProj = projection.project(polyline, tempLinear);
                        const buffered = geometryEngine.buffer(tempProj, bufferDistance, "meters");
                        // reproject back to layer's SR
                        bufferGeom = projection.project(buffered, layerSR);
                        } else {
                        bufferGeom = geometryEngine.buffer(polylineProjected, bufferDistance, "meters");
                        }

                        // <<< ADD THIS BLOCK TO SHOW THE BUFFER ON THE MAP >>>
                        require(["esri/Graphic"], (Graphic) => {
                        const bufferGraphic = new Graphic({
                            geometry: bufferGeom,
                            symbol: {
                            type: "simple-fill",
                            color: [200, 160, 255, 0.1], // light blue, semi-transparent
                            outline: {
                                // color: [0, 0, 255, 0.8],
                                color: [128, 0, 128, 0.2], // bright blue line
                                width: 0.5
                            }
                            }
                        });
                        view.graphics.add(bufferGraphic);
                        });

                        // Convert buffer back to WGS84 for querying (layer likely in 4326)
                        const bufferWGS84 = projection.project(bufferGeom, { wkid: 4326 });

                        const query = layer.createQuery();
                        query.geometry = bufferWGS84;
                        query.spatialRelationship = "intersects";
                        query.returnGeometry = true;
                        query.outFields = ["access_status", "impasse_reasons"];

                        layer.queryFeatures(query).then((results) => {
                        if (results.features.length > 0) {
                            alert(`⚠️ WARNING: ${results.features.length} closures found within ${bufferDistance}m of your route.`);
                            results.features.forEach(f => {
                            f.symbol = {
                                type: "simple-marker",
                                color: "red",
                                size: "10px"
                            };
                            });
                            view.graphics.addMany(results.features);
                        } else {
                            alert("✅ No closures found near your uploaded route.");
                        }
                        }).catch(err => console.error("Query failed", err));
                    });
                    });
                };
                reader.readAsText(file);
                }

            });
        };
    </script>
  </body>
</html>
